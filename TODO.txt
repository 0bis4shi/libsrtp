For NSS integration:

* Add GCM and ICM support
* Add testing support for GCM and ICM
* Add SRTP support for NSS-based GCM


autoconf && ./configure --enable-nss --with-nss-dir=../nss/dist/Debug/ --enable-debug-logging --enable-log-stdout && make clean && make
autoconf && ./configure --enable-openssl --enable-debug-logging --enable-log-stdout && make clean && make





alloc: (location: 0x7fdff7400340) allocated
alloc: (location: 0x7fdff7402740) allocated
cipher: testing encryption
aes icm ossl: key:  2b7e151628aed2a6abf7158809cf4f3c
aes icm ossl: offset: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: plaintext:    0000000000000000000000000000000000000000000000000000000000000000
aes icm ossl: setting iv: 00000000000000000000000000000000
aes icm ossl: set_counter: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
aes icm ossl: rs0: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: ciphertext:   e03ead0935c95e80e166b16dd92b4eb4d23513162b02d0f72a43a2fe4a5f97ab
cipher: testing decryption
aes icm ossl: key:  2b7e151628aed2a6abf7158809cf4f3c
aes icm ossl: offset: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: ciphertext:    e03ead0935c95e80e166b16dd92b4eb4d23513162b02d0f72a43a2fe4a5f97ab
aes icm ossl: setting iv: 00000000000000000000000000000000
aes icm ossl: set_counter: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
aes icm ossl: rs0: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: plaintext:   0000000000000000000000000000000000000000000000000000000000000000
alloc: (location: 0x7fdff7402740) freed
alloc: (location: 0x7fdff7400340) freed
aes icm ossl: allocating cipher with key length 30
alloc: (location: 0x7fdff7400340) allocated
alloc: (location: 0x7fdff7402740) allocated
cipher: random plaintext length 50


alloc: (location: 0x7f7efd5095c0) allocated
alloc: (location: 0x7f7efd5095e0) allocated
cipher: testing encryption
aes icm nss: key:  2b7e151628aed2a6abf7158809cf4f3c
aes icm nss: offset: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: plaintext:    0000000000000000000000000000000000000000000000000000000000000000
aes icm nss: setting iv: 00000000000000000000000000000000
aes icm nss: set_counter: f0f1f2f3f4f5f6f7f8f9fafbfcfd0000
cipher: ciphertext:   7df76b0c1ab899b33e42f047b91b546f57127d4034b1bebfaef466b9c7726fc6
cipher: test case 0 failed
cipher: (failure at byte 0)
cipher: c computed: 7df76b0c1ab899b33e42f047b91b546f57127d4034b1bebfaef466b9c7726fc60000000000000000000000000000000020a879effe7f0000898d3663ff7f0000
cipher: c expected: e03ead0935c95e80e166b16dd92b4eb4d23513162b02d0f72a43a2fe4a5f97abeab234764e517b2d3d160d587d8c86219740f65f99b6bcf7f0f1f2f3f4f5f6f7
alloc: (location: 0x7f7efd5095e0) freed
alloc: (location: 0x7f7efd5095c0) freed
failed with error code 11





============



Done on plane:

* Sketch out PR for -double
* Update double.py to support E2E extensions
* Sketch out rewrite of -framework




=======

OHB Config Byte:

+-+-+-+-+-+-+-+-+
|P|Q|M|R|R|B|S|X|
+-+-+-+-+-+-+-+-+


* Config byte:
  * P: PT is present
  * Q: SEQ is present
  * M: Marker bit is present
  * B: Original value of the RTP Marker bit, if M
  * R: Reserved, MUST be set to 0
  * S: Only HBH transform should be applied
  * X: Another octet follows (in a format TBD)
* OHB = config PT? SEQ?

* Assumption: Transform is configured with config byte
  * Protection profile
  * EKT
  * Just pass it to srtp_protect
  * Main questions: 
    * Does it need to be negotiated?
    * Does the protection profile need to have fixed overhead?
      * Yes => Protection profile
    * Does it need to be variable per-packet?
      * Yes => just pass it to srtp_protect

* Encryption operation(payload, original_header)
  * ct_inner, tag_inner = Encrypt(pt=payload, aad=original_header)
  * ohb = ohb(config, header)
  * If S=1, return:
    * Ciphertext = ct_inner
    * Tag = tag_inner || 0*ohb_len || 0*tag_len
  * ct_outer, tag_outer = Encrypt(pt=payload || tag_inner, aad=original_header)
  * Return:
    * Ciphertext = ct_outer[:len(ct_inner)]
    * Tag = ct_outer[len(ct_inner):] || ohb || tag_outer

* Decryption operation(payload, tag, wire_header)
  * tag_inner_enc, ohb_enc, tag_outer = split(tag)
  * pt_outer = Decrypt(ct=payload || tag_inner_enc || ohb_enc, tag_outer)
  * ct_inner, tag_inner, ohb = split(pt_outer)
  * original_header = restore_original_values(ohb, wire_header)
  * pt_inner = Decrypt(ct=ct_inner, aad=original_header, tag=tag_inner)
  * Return pt_inner

Enc Dec
 |   ^  |<---- Payload ---->|
 |   |  |<---- CT_inner --->|<-- ITag -->|
 |   |  |<---- CT_inner --->|<-- ITag -->|<- OHB ->|
 |   |  |<----------------CT_outer---------------->|<-- OTag -->|
 V   |  |<---- Payload ---->|<-------------- Tag -------------->|


=====


** Have EKT code actually use the keys it gets
** Send EKT old vs. new / long vs. short
** Decode EKT old vs. new as appropriate


** Moving OHB to payload
  ** Cache outer AAD; transform to inner AAD when you get the payload
  ** 


=====


XX OHB
-- Add support for 2-byte header form
-- Get wired up through DTLS-SRTP
-- Double back to validate known-answer test vectors
-- Automatically only do outer operations if inner half of key is zero

In Firefox:
-- Force use of -double
-- Send OHB
-- Negotiate OHB in SDP


** RTP protection
** RTP header extension encryption
  => ICM with hbh key
  => MUST NOT be applied to OHB
** RTCP protection


##########


# E2E Extensions Length

    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-------------------------------+
   |  ID   | len=1 |     E2E Extensions Length     |
   +-+-+-+-+-+-+-+-+-------------------------------+


# OHB

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+---------------+
   |  ID   | len=0 |A|     PT      |
   +-+-+-+-+-+-+-+-+---------------+

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 6 4 5 6 7 8 9 1
   +-+-+-+-+-+-+-+-+---------------+-------------------------------+
   |  ID   | len=2 |A|     PT      |        Sequence Number        |
   +-+-+-+-+-+-+-+-+---------------+-------------------------------+

The "A" bit indicates whether the PT value is "active".  That is, if A=0, then PT MUST be ignored.


# Header Extension Handling

If X=0, AAD_inner == AAD_outer

If X=1:

* RFC 5285 extension header MUST be present
* First extension MUST be either E2EEL or OHB
* If the length of the first extension is 2, then it's an E2EEL
  * AAD_inner = AAD_outer[:E2EEL] (and amend extensions length to nearest multiple)
  * At the length indicated by the E2EEL, there MUST be an OHB
* OHB processing:
  * Len=1 && A=0: No action
  * Len=1 && A=1: Replace PT
  * Len=3 && A=0: Replace SEQ
  * Len=3 && A=1: Replace PT and SEQ


* 
