<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libSRTP: SRTP events and callbacks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="docs.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSRTP
   &#160;<span id="projectnumber">2.1.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SRTP events and callbacks<div class="ingroups"><a class="el" href="group__SRTP.html">Secure RTP</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>libSRTP can use a user-provided callback function to handle events.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__event__data__t.html" title="srtp_event_data_t is the structure passed as a callback to the event handler function ...">srtp_event_data_t</a> is the structure passed as a callback to the event handler function  <a href="structsrtp__event__data__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafc7272d1ef1e6990a61bb165f488badf"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#gafc7272d1ef1e6990a61bb165f488badf">srtp_event_data_t</a></td></tr>
<tr class="memdesc:gafc7272d1ef1e6990a61bb165f488badf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structsrtp__event__data__t.html" title="srtp_event_data_t is the structure passed as a callback to the event handler function ...">srtp_event_data_t</a> is the structure passed as a callback to the event handler function  <a href="#gafc7272d1ef1e6990a61bb165f488badf">More...</a><br/></td></tr>
<tr class="separator:gafc7272d1ef1e6990a61bb165f488badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b9a85ae39f27683b6cd12562d0441a"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#ga17b9a85ae39f27683b6cd12562d0441a">srtp_event_handler_func_t</a> )(<a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a> *data)</td></tr>
<tr class="memdesc:ga17b9a85ae39f27683b6cd12562d0441a"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_event_handler_func_t is the function prototype for the event handler.  <a href="#ga17b9a85ae39f27683b6cd12562d0441a">More...</a><br/></td></tr>
<tr class="separator:ga17b9a85ae39f27683b6cd12562d0441a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gada9b262f3a03e413bce4b5d0476d2ce0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#gada9b262f3a03e413bce4b5d0476d2ce0">srtp_event_t</a> { <a class="el" href="group__SRTPevents.html#ggada9b262f3a03e413bce4b5d0476d2ce0a2f775d1a986caad518a14f3db65e49b3">event_ssrc_collision</a>, 
<a class="el" href="group__SRTPevents.html#ggada9b262f3a03e413bce4b5d0476d2ce0a56134ad6b53c45dc179d9a7f93b5be74">event_key_soft_limit</a>, 
<a class="el" href="group__SRTPevents.html#ggada9b262f3a03e413bce4b5d0476d2ce0ab756778215c645d14341da8964d9fc34">event_key_hard_limit</a>, 
<a class="el" href="group__SRTPevents.html#ggada9b262f3a03e413bce4b5d0476d2ce0a619d440fc572503eee6c0503517af18b">event_packet_index_limit</a>
 }</td></tr>
<tr class="memdesc:gada9b262f3a03e413bce4b5d0476d2ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_event_t defines events that need to be handled  <a href="group__SRTPevents.html#gada9b262f3a03e413bce4b5d0476d2ce0">More...</a><br/></td></tr>
<tr class="separator:gada9b262f3a03e413bce4b5d0476d2ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8686a2a34d9bd6aefb7376bbd68c0d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#ga8686a2a34d9bd6aefb7376bbd68c0d65">srtp_install_event_handler</a> (<a class="el" href="group__SRTPevents.html#ga17b9a85ae39f27683b6cd12562d0441a">srtp_event_handler_func_t</a> func)</td></tr>
<tr class="memdesc:ga8686a2a34d9bd6aefb7376bbd68c0d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the event handler to the function supplied by the caller.  <a href="#ga8686a2a34d9bd6aefb7376bbd68c0d65">More...</a><br/></td></tr>
<tr class="separator:ga8686a2a34d9bd6aefb7376bbd68c0d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04a35696120be823bafcd255eec04708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga04a35696120be823bafcd255eec04708"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#ga04a35696120be823bafcd255eec04708">srtp_get_version_string</a> (void)</td></tr>
<tr class="memdesc:ga04a35696120be823bafcd255eec04708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the version string of the library. <br/></td></tr>
<tr class="separator:ga04a35696120be823bafcd255eec04708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga437336a0d87757092ca5959033ccef5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga437336a0d87757092ca5959033ccef5b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#ga437336a0d87757092ca5959033ccef5b">srtp_get_version</a> (void)</td></tr>
<tr class="memdesc:ga437336a0d87757092ca5959033ccef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numeric representation of the library version. <br/></td></tr>
<tr class="separator:ga437336a0d87757092ca5959033ccef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e3b29168ef5c786e655c5623f7494d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#gae4e3b29168ef5c786e655c5623f7494d">srtp_set_debug_module</a> (char *mod_name, int v)</td></tr>
<tr class="memdesc:gae4e3b29168ef5c786e655c5623f7494d"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_set_debug_module(mod_name, v)  <a href="#gae4e3b29168ef5c786e655c5623f7494d">More...</a><br/></td></tr>
<tr class="separator:gae4e3b29168ef5c786e655c5623f7494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dded6ec2177727f97afda2424c94e46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8dded6ec2177727f97afda2424c94e46"></a>
<a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#ga8dded6ec2177727f97afda2424c94e46">srtp_list_debug_modules</a> (void)</td></tr>
<tr class="memdesc:ga8dded6ec2177727f97afda2424c94e46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__SRTPevents.html#ga8dded6ec2177727f97afda2424c94e46" title="srtp_list_debug_modules() outputs a list of debugging modules ">srtp_list_debug_modules()</a> outputs a list of debugging modules <br/></td></tr>
<tr class="separator:ga8dded6ec2177727f97afda2424c94e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab156c843d57185e721fc359b5f19a395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#gab156c843d57185e721fc359b5f19a395">srtp_get_protect_trailer_length</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, uint32_t use_mki, uint32_t mki_index, uint32_t *length)</td></tr>
<tr class="memdesc:gab156c843d57185e721fc359b5f19a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_get_protect_trailer_length(session, use_mki, mki_index, length)  <a href="#gab156c843d57185e721fc359b5f19a395">More...</a><br/></td></tr>
<tr class="separator:gab156c843d57185e721fc359b5f19a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4e12fabfc9f248472f5166f4ce6c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SRTPevents.html#gace4e12fabfc9f248472f5166f4ce6c3c">srtp_get_protect_rtcp_trailer_length</a> (<a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session, uint32_t use_mki, uint32_t mki_index, uint32_t *length)</td></tr>
<tr class="memdesc:gace4e12fabfc9f248472f5166f4ce6c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">srtp_get_protect_rtcp_trailer_length(session, use_mki, mki_index, length)  <a href="#gace4e12fabfc9f248472f5166f4ce6c3c">More...</a><br/></td></tr>
<tr class="separator:gace4e12fabfc9f248472f5166f4ce6c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>libSRTP allows a user to provide a callback function to handle events that need to be dealt with outside of the data plane (see the enum srtp_event_t for a description of these events). Dealing with these events is not a strict necessity; they are not security-critical, but the application may suffer if they are not handled. The function srtp_set_event_handler() is used to provide the callback function.</p>
<p>A default event handler that merely reports on the events as they happen is included. It is also possible to set the event handler function to NULL, in which case all events will just be silently ignored. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gafc7272d1ef1e6990a61bb165f488badf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a>  <a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The struct <a class="el" href="structsrtp__event__data__t.html" title="srtp_event_data_t is the structure passed as a callback to the event handler function ...">srtp_event_data_t</a> holds the data passed to the event handler function. </p>

</div>
</div>
<a class="anchor" id="ga17b9a85ae39f27683b6cd12562d0441a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( srtp_event_handler_func_t)(<a class="el" href="structsrtp__event__data__t.html">srtp_event_data_t</a> *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The typedef srtp_event_handler_func_t is the prototype for the event handler function. It has as its only argument an <a class="el" href="structsrtp__event__data__t.html" title="srtp_event_data_t is the structure passed as a callback to the event handler function ...">srtp_event_data_t</a> which describes the event that needs to be handled. There can only be a single, global handler for all events in libSRTP. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gada9b262f3a03e413bce4b5d0476d2ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__SRTPevents.html#gada9b262f3a03e413bce4b5d0476d2ce0">srtp_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum srtp_event_t defines events that need to be handled outside the `data plane', such as SSRC collisions and key expirations.</p>
<p>When a key expires or the maximum number of packets has been reached, an SRTP stream will enter an `expired' state in which no more packets can be protected or unprotected. When this happens, it is likely that you will want to either deallocate the stream (using <a class="el" href="group__SRTP.html#gaa9272c20fefc4ebe5b4542ab5045dd75" title="srtp_remove_stream() deallocates an SRTP stream. ">srtp_remove_stream()</a>), and possibly allocate a new one.</p>
<p>When an SRTP stream expires, the other streams in the same session are unaffected, unless key sharing is used by that stream. In the latter case, all of the streams in the session will expire. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggada9b262f3a03e413bce4b5d0476d2ce0a2f775d1a986caad518a14f3db65e49b3"></a>event_ssrc_collision</em>&#160;</td><td class="fielddoc">
<p>An SSRC collision occured. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggada9b262f3a03e413bce4b5d0476d2ce0a56134ad6b53c45dc179d9a7f93b5be74"></a>event_key_soft_limit</em>&#160;</td><td class="fielddoc">
<p>An SRTP stream reached the soft key usage limit and will expire soon. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggada9b262f3a03e413bce4b5d0476d2ce0ab756778215c645d14341da8964d9fc34"></a>event_key_hard_limit</em>&#160;</td><td class="fielddoc">
<p>An SRTP stream reached the hard key usage limit and has expired. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggada9b262f3a03e413bce4b5d0476d2ce0a619d440fc572503eee6c0503517af18b"></a>event_packet_index_limit</em>&#160;</td><td class="fielddoc">
<p>An SRTP stream reached the hard packet limit (2^48 packets). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gace4e12fabfc9f248472f5166f4ce6c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_get_protect_rtcp_trailer_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>use_mki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mki_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the length of the amount of data Lib SRTP will add to the packet during the protect process. The length is returned in the length parameter</p>
<p>returns err_status_ok on success, err_status_bad_mki if the MKI index is invalid </p>

</div>
</div>
<a class="anchor" id="gab156c843d57185e721fc359b5f19a395"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_get_protect_trailer_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a>&#160;</td>
          <td class="paramname"><em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>use_mki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mki_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the length of the amount of data Lib SRTP will add to the packet during the protect process. The length is returned in the length parameter</p>
<p>returns err_status_ok on success, err_status_bad_mki if the MKI index is invalid </p>

</div>
</div>
<a class="anchor" id="ga8686a2a34d9bd6aefb7376bbd68c0d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_install_event_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SRTPevents.html#ga17b9a85ae39f27683b6cd12562d0441a">srtp_event_handler_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function call srtp_install_event_handler(func) sets the event handler function to the value func. The value NULL is acceptable as an argument; in this case, events will be ignored rather than handled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>is a pointer to a fuction that takes an <a class="el" href="structsrtp__event__data__t.html" title="srtp_event_data_t is the structure passed as a callback to the event handler function ...">srtp_event_data_t</a> pointer as an argument and returns void. This function will be used by libSRTP to handle events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae4e3b29168ef5c786e655c5623f7494d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SRTP.html#ga2d9e365ccac332e03bf4a37e6b84ad76">srtp_err_status_t</a> srtp_set_debug_module </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mod_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>sets dynamic debugging to the value v (0 for off, 1 for on) for the debug module with the name mod_name</p>
<p>returns err_status_ok on success, err_status_fail otherwise </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
