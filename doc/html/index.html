<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libSRTP: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="docs.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libSRTP
   &#160;<span id="projectnumber">2.1.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">libSRTP Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="introduction-to-libsrtp"></a> </p>
<h1>Introduction to libSRTP</h1>
<p>This package provides an implementation of the Secure Real-time Transport Protocol (SRTP), the Universal Security Transform (UST), and a supporting cryptographic kernel. The SRTP API is documented in <a class="el" href="srtp_8h_source.html">include/srtp.h</a>, and the library is in libsrtp2.a (after compilation).</p>
<p>This document describes libSRTP, the Open Source Secure RTP library from Cisco Systems, Inc. RTP is the Real-time Transport Protocol, an IETF standard for the transport of real-time data such as telephony, audio, and video, defined by <a href="https://www.ietf.org/rfc/rfc3550.txt">RFC 3550</a>. Secure RTP (SRTP) is an RTP profile for providing confidentiality to RTP data and authentication to the RTP header and payload. SRTP is an IETF Standard, defined in <a href="https://www.ietf.org/rfc/rfc3711.txt">RFC 3711</a>, and was developed in the IETF Audio/Video Transport (AVT) Working Group. This library supports all of the mandatory features of SRTP, but not all of the optional features. See the <a href="#supported-features">Supported Features</a> section for more detailed information.</p>
<p>This document is also used to generate the documentation files in the /doc/ folder where a more detailed reference to the libSRTP API and related functions can be created (requires installing doxygen.). The reference material is created automatically from comments embedded in some of the C header files. The documentation is organized into modules in order to improve its clarity. These modules do not directly correspond to files. An underlying cryptographic kernel provides much of the basic functionality of libSRTP but is mostly undocumented because it does its work behind the scenes. </p>
<hr/>
<p><a class="anchor" id="contact"></a> </p>
<h1>Contact Us</h1>
<ul>
<li><a href="#" onclick="location.href='mai'+'lto:'+'lib'+'sr'+'tp@'+'li'+'sts'+'.p'+'ack'+'et'+'ize'+'r.'+'com'; return false;">libsrtp@lists.packetizer.com</a> general mailing list for news / announcements / discussions. This is an open list, see <a href="https://lists.packetizer.com/mailman/listinfo/libsrtp">https://lists.packetizer.com/mailman/listinfo/libsrtp</a> for singing up.</li>
<li><a href="#" onclick="location.href='mai'+'lto:'+'lib'+'sr'+'tp-'+'se'+'cur'+'it'+'y@l'+'is'+'ts.'+'pa'+'cke'+'ti'+'zer'+'.c'+'om'; return false;">libsrtp-security@lists.packetizer.com</a> for disclosing security issues to the libsrtp maintenance team. This is a closed list but anyone can send to it.</li>
</ul>
<hr/>
<p><a class="anchor" id="contents"></a> </p>
<h2>Contents</h2>
<ul>
<li><a href="#introduction-to-libsrtp">Introduction to libSRTP</a><ul>
<li><a href="#contact">Contact Us</a></li>
<li><a href="#contents">Contents</a></li>
</ul>
</li>
<li><a href="#license-and-disclaimer">License and Disclaimer</a></li>
<li><a href="#libsrtp-overview">libSRTP Overview</a><ul>
<li><a href="#secure-rtp-background">Secure RTP Background</a></li>
<li><a href="#supported-features">Supported Features</a></li>
<li><a href="#implementation-notes">Implementation Notes</a></li>
</ul>
</li>
<li><a href="#installing-and-building-libsrtp">Installing and Building libSRTP</a></li>
<li><a href="#applications">Applications</a><ul>
<li><a href="#example-code">Example Code</a></li>
</ul>
</li>
<li><a href="#credits">Credits</a></li>
<li><a href="#references">References</a> <hr/>
</li>
</ul>
<p><a class="anchor" id="license-and-disclaimer"></a> </p>
<h1>License and Disclaimer</h1>
<p>libSRTP is distributed under the following license, which is included in the source code distribution. It is reproduced in the manual in case you got the library from another source.</p>
<blockquote class="doxtable">
<p>Copyright (c) 2001-2005 Cisco Systems, Inc. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the Cisco Systems, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p></p>
</blockquote>
<hr/>
<p><a class="anchor" id="libsrtp-overview"></a> </p>
<h1>libSRTP Overview</h1>
<p>libSRTP provides functions for protecting RTP and RTCP. RTP packets can be encrypted and authenticated (using the <code><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a></code> function), turning them into SRTP packets. Similarly, SRTP packets can be decrypted and have their authentication verified (using the <code><a class="el" href="group__SRTP.html#gad4c3669a5b8cb19f3dfbdbefb90ee94a" title="srtp_unprotect() is the Secure RTP receiver-side packet processing function. ">srtp_unprotect()</a></code> function), turning them into RTP packets. Similar functions apply security to RTCP packets.</p>
<p>The typedef <code>srtp_stream_t</code> points to a structure holding all of the state associated with an SRTP stream, including the keys and parameters for cipher and message authentication functions and the anti-replay data. A particular <code>srtp_stream_t</code> holds the information needed to protect a particular RTP and RTCP stream. This datatype is intentionally opaque in order to better seperate the libSRTP API from its implementation.</p>
<p>Within an SRTP session, there can be multiple streams, each originating from a particular sender. Each source uses a distinct stream context to protect the RTP and RTCP stream that it is originating. The typedef <code>srtp_t</code> points to a structure holding all of the state associated with an SRTP session. There can be multiple stream contexts associated with a single <code>srtp_t</code>. A stream context cannot exist indepent from an <code>srtp_t</code>, though of course an <code>srtp_t</code> can be created that contains only a single stream context. A device participating in an SRTP session must have a stream context for each source in that session, so that it can process the data that it receives from each sender.</p>
<p>In libSRTP, a session is created using the function <code><a class="el" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477" title="srtp_create() allocates and initializes an SRTP session. ">srtp_create()</a></code>. The policy to be implemented in the session is passed into this function as an <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a></code> structure. A single one of these structures describes the policy of a single stream. These structures can also be linked together to form an entire session policy. A linked list of <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a></code> structures is equivalent to a session policy. In such a policy, we refer to a single <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a></code> as an <em>element</em>.</p>
<p>An <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a></code> strucutre contains two <code>crypto_policy_t</code> structures that describe the cryptograhic policies for RTP and RTCP, as well as the SRTP master key and the SSRC value. The SSRC describes what to protect (e.g. which stream), and the <code>crypto_policy_t</code> structures describe how to protect it. The key is contained in a policy element because it simplifies the interface to the library. In many cases, it is desirable to use the same cryptographic policies across all of the streams in a session, but to use a distinct key for each stream. A <code>crypto_policy_t</code> structure can be initialized by using either the <code>crypto_policy_set_rtp_default()</code> or <code>crypto_policy_set_rtcp_default()</code> functions, which set a crypto policy structure to the default policies for RTP and RTCP protection, respectively. </p>
<hr/>
<p><a class="anchor" id="secure-rtp-background"></a> </p>
<h2>Secure RTP Background</h2>
<p>In this section we review SRTP and introduce some terms that are used in libSRTP. An RTP session is defined by a pair of destination transport addresses, that is, a network address plus a pair of UDP ports for RTP and RTCP. RTCP, the RTP control protocol, is used to coordinate between the participants in an RTP session, e.g. to provide feedback from receivers to senders. An <em>SRTP session</em> is similarly defined; it is just an RTP session for which the SRTP profile is being used. An SRTP session consists of the traffic sent to the SRTP or SRTCP destination transport addresses. Each participant in a session is identified by a synchronization source (SSRC) identifier. Some participants may not send any SRTP traffic; they are called receivers, even though they send out SRTCP traffic, such as receiver reports.</p>
<p>RTP allows multiple sources to send RTP and RTCP traffic during the same session. The synchronization source identifier (SSRC) is used to distinguish these sources. In libSRTP, we call the SRTP and SRTCP traffic from a particular source a <em>stream</em>. Each stream has its own SSRC, sequence number, rollover counter, and other data. A particular choice of options, cryptographic mechanisms, and keys is called a <em>policy</em>. Each stream within a session can have a distinct policy applied to it. A session policy is a collection of stream policies.</p>
<p>A single policy can be used for all of the streams in a given session, though the case in which a single <em>key</em> is shared across multiple streams requires care. When key sharing is used, the SSRC values that identify the streams <b>must</b> be distinct. This requirement can be enforced by using the convention that each SRTP and SRTCP key is used for encryption by only a single sender. In other words, the key is shared only across streams that originate from a particular device (of course, other SRTP participants will need to use the key for decryption). libSRTP supports this enforcement by detecting the case in which a key is used for both inbound and outbound data. </p>
<hr/>
<p><a class="anchor" id="supported-features"></a> </p>
<h2>Supported Features</h2>
<p>This library supports all of the mandatory-to-implement features of SRTP (as defined by the most recent Internet Draft). Some of these features can be selected (or de-selected) at run time by setting an appropriate policy; this is done using the structure <code><a class="el" href="structsrtp__policy__t.html" title="represents the policy for an SRTP session. ">srtp_policy_t</a></code>. Some other behaviors of the protocol can be adapted by defining an approriate event handler for the exceptional events; see the SRTPevents section in the generated documentation.</p>
<p>Some options that are not included in the specification are supported. Most notably, the TMMH authentication function is included, though it was removed from the SRTP Internet Draft during the summer of 2002.</p>
<p>Some options that are described in the SRTP specification are not supported. This includes</p>
<ul>
<li>the Master Key Index (MKI),</li>
<li>key derivation rates other than zero,</li>
<li>the cipher F8,</li>
<li>anti-replay lists with sizes other than 128,</li>
<li>the use of the packet index to select between master keys.</li>
</ul>
<p>The user should be aware that it is possible to misuse this libary, and that the result may be that the security level it provides is inadequate. If you are implementing a feature using this library, you will want to read the Security Considerations section of the Internet Draft. In addition, it is important that you read and understand the terms outlined in the <a href="#license-and-disclaimer">License and Disclaimer</a> section. </p>
<hr/>
<p><a class="anchor" id="implementation-notes"></a> </p>
<h2>Implementation Notes</h2>
<ul>
<li>The <code><a class="el" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2" title="srtp_protect() is the Secure RTP sender-side packet processing function. ">srtp_protect()</a></code> function assumes that the buffer holding the rtp packet has enough storage allocated that the authentication tag can be written to the end of that packet. If this assumption is not valid, memory corruption will ensue.</li>
<li>Automated tests for the crypto functions are provided through the <code>cipher_type_self_test()</code> and <code>auth_type_self_test()</code> functions. These functions should be used to test each port of this code to a new platform.</li>
<li>Replay protection is contained in the crypto engine, and tests for it are provided.</li>
<li>This implementation provides calls to initialize, protect, and unprotect RTP packets, and makes as few as possible assumptions about how these functions will be called. For example, the caller is not expected to provide packets in order (though if they're called more than 65k out of sequence, synchronization will be lost).</li>
<li>The sequence number in the rtp packet is used as the low 16 bits of the sender's local packet index. Note that RTP will start its sequence number in a random place, and the SRTP layer just jumps forward to that number at its first invocation. An earlier version of this library used initial sequence numbers that are less than 32,768; this trick is no longer required as the <code>rdbx_estimate_index(...)</code> function has been made smarter.</li>
<li>The replay window is 128 bits in length, and is hard-coded to this value for now. <hr/>
</li>
</ul>
<p><a class="anchor" id="installing-and-building-libsrtp"></a> </p>
<h1>Installing and Building libSRTP</h1>
<p>To install libSRTP, download the latest release of the distribution from <a href="https://github.com/cisco/libsrtp/releases">https://github.com/cisco/libsrtp/releases</a>. You probably want to get the most recent release. Unpack the distribution and extract the source files; the directory into which the source files will go is named <code>libsrtp-A-B-C</code> where <code>A</code> is the version number, <code>B</code> is the major release number and <code>C</code> is the minor release number.</p>
<p>libSRTP uses the GNU <code>autoconf</code> and <code>make</code> utilities (BSD make will not work; if both versions of make are on your platform, you can invoke GNU make as <code>gmake</code>.). In the <code>libsrtp</code> directory, run the configure script and then make:</p>
<div class="fragment"><div class="line">./configure [ options ]</div>
<div class="line">make</div>
</div><!-- fragment --><p>The configure script accepts the following options:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Description  </th></tr>
<tr>
<td>--help </td><td>provides a usage summary </td></tr>
<tr>
<td>--enable-debug-logging </td><td>enable debug logging in all modules </td></tr>
<tr>
<td>--enable-log-stdout </td><td>redirecting logging to stdout </td></tr>
<tr>
<td>--with-log-file &lt;file&gt; </td><td>use file for logging </td></tr>
<tr>
<td>--enable-openssl </td><td>use OpenSSL crypto primitives </td></tr>
<tr>
<td>--with-openssl-dir </td><td>Specify location of OpenSSL installation </td></tr>
<tr>
<td>--enable-openssl-kdf use</td><td>OpenSSL SRTP KDF algorithm </td></tr>
<tr>
<td>--gdoi </td><td>use GDOI key management (disabled at present) </td></tr>
</table>
<p>By default there is no log output, logging can be enabled to be output to stdout or a given file using the configure options.</p>
<p>This package has been tested on the following platforms: Mac OS X (powerpc-apple-darwin1.4), Cygwin (i686-pc-cygwin), Solaris (sparc-sun-solaris2.6), RedHat Linux 7.1 and 9 (i686-pc-linux), and OpenBSD (sparc-unknown-openbsd2.7). </p>
<hr/>
<p><a class="anchor" id="applications"></a> </p>
<h1>Applications</h1>
<p>Several test drivers and a simple and portable srtp application are included in the <code>test/</code> subdirectory.</p>
<table class="doxtable">
<tr>
<th>Test driver </th><th>Function tested  </th></tr>
<tr>
<td>kernel_driver </td><td>crypto kernel (ciphers, auth funcs, rng) </td></tr>
<tr>
<td>srtp_driver </td><td>srtp in-memory tests (does not use the network) </td></tr>
<tr>
<td>rdbx_driver </td><td>rdbx (extended replay database) </td></tr>
<tr>
<td>roc_driver </td><td>extended sequence number functions </td></tr>
<tr>
<td>replay_driver </td><td>replay database </td></tr>
<tr>
<td>cipher_driver </td><td>ciphers </td></tr>
<tr>
<td>auth_driver </td><td>hash functions </td></tr>
</table>
<p>The app <code>rtpw</code> is a simple rtp application which reads words from <code>/usr/dict/words</code> and then sends them out one at a time using [s]rtp. Manual srtp keying uses the -k option; automated key management using gdoi will be added later.</p>
<p>usage: </p>
<div class="fragment"><div class="line">rtpw [[-d &lt;debug&gt;]* [-k|b &lt;key&gt; [-a][-e &lt;key size&gt;][-g]] [-s | -r] dest_ip dest_port] | [-l]</div>
</div><!-- fragment --><p>Either the -s (sender) or -r (receiver) option must be chosen. The values <code>dest_ip</code>, <code>dest_port</code> are the IP address and UDP port to which the dictionary will be sent, respectively.</p>
<p>The options are:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Description  </th></tr>
<tr>
<td>-s </td><td>(S)RTP sender - causes app to send words </td></tr>
<tr>
<td>-r </td><td>(S)RTP receive - causes app to receive words </td></tr>
<tr>
<td>-k &lt;key&gt; </td><td>use SRTP master key &lt;key&gt;, where the key is a hexadecimal (without the leading "0x") </td></tr>
<tr>
<td>-b &lt;key&gt; </td><td>same as -k but with base64 encoded key </td></tr>
<tr>
<td>-e &lt;keysize&gt; </td><td>encrypt/decrypt (for data confidentiality) (requires use of -k option as well) (use 128, 192, or 256 for keysize) </td></tr>
<tr>
<td>-g </td><td>use AES-GCM mode (must be used with -e) </td></tr>
<tr>
<td>-a </td><td>message authentication (requires use of -k option as well) </td></tr>
<tr>
<td>-l </td><td>list the available debug modules </td></tr>
<tr>
<td>-d &lt;debug&gt; </td><td>turn on debugging for module &lt;debug&gt; </td></tr>
</table>
<p>In order to get random 30-byte values for use as key/salt pairs , you can use the following bash function to format the output of <code>/dev/random</code> (where that device is available).</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> randhex() {</div>
<div class="line">   cat /dev/random | od --read-bytes=32 --width=32 -x | awk <span class="stringliteral">&#39;{ print $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 }&#39;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>An example of an SRTP session using two rtpw programs follows:</p>
<div class="fragment"><div class="line">set k=c1eec3717da76195bb878578790af71c4ee9f859e197a414a78d5abc7451</div>
<div class="line"></div>
<div class="line">[sh1]$ test/rtpw -s -k $k -e 128 -a 0.0.0.0 9999</div>
<div class="line">Security services: confidentiality message authentication</div>
<div class="line">set master key/salt to C1EEC3717DA76195BB878578790AF71C/4EE9F859E197A414A78D5ABC7451</div>
<div class="line">setting SSRC to 2078917053</div>
<div class="line">sending word: A</div>
<div class="line">sending word: a</div>
<div class="line">sending word: aa</div>
<div class="line">sending word: aal</div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">[sh2]$ test/rtpw -r -k $k -e 128 -a 0.0.0.0 9999</div>
<div class="line">security services: confidentiality message authentication</div>
<div class="line">set master key/salt to C1EEC3717DA76195BB878578790AF71C/4EE9F859E197A414A78D5ABC7451</div>
<div class="line">19 octets received from SSRC 2078917053 word: A</div>
<div class="line">19 octets received from SSRC 2078917053 word: a</div>
<div class="line">20 octets received from SSRC 2078917053 word: aa</div>
<div class="line">21 octets received from SSRC 2078917053 word: aal</div>
<div class="line">...</div>
</div><!-- fragment --> <hr/>
<p><a class="anchor" id="example-code"></a> </p>
<h2>Example Code</h2>
<p>This section provides a simple example of how to use libSRTP. The example code lacks error checking, but is functional. Here we assume that the value ssrc is already set to describe the SSRC of the stream that we are sending, and that the functions <code>get_rtp_packet()</code> and <code>send_srtp_packet()</code> are available to us. The former puts an RTP packet into the buffer and returns the number of octets written to that buffer. The latter sends the RTP packet in the buffer, given the length as its second argument.</p>
<div class="fragment"><div class="line"><a class="code" href="group__SRTP.html#ga1c404a756add908efb805d6b729994d0">srtp_t</a> session;</div>
<div class="line"><a class="code" href="structsrtp__policy__t.html">srtp_policy_t</a> policy;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Set key to predetermined value</span></div>
<div class="line">uint8_t key[30] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</div>
<div class="line">                   0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,</div>
<div class="line">                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,</div>
<div class="line">                   0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D};</div>
<div class="line"></div>
<div class="line"><span class="comment">// initialize libSRTP</span></div>
<div class="line"><a class="code" href="group__SRTP.html#gaf7be4aa17ae3ac2527bf8a499d13739c">srtp_init</a>();</div>
<div class="line"></div>
<div class="line"><span class="comment">// set policy to describe a policy for an SRTP stream</span></div>
<div class="line">crypto_policy_set_rtp_default(&amp;policy.<a class="code" href="structsrtp__policy__t.html#a7a2bce58e854e44e6d449ec7141b33e2">rtp</a>);</div>
<div class="line">crypto_policy_set_rtcp_default(&amp;policy.<a class="code" href="structsrtp__policy__t.html#aa1847e6734f709f86e79d0600bc4f24f">rtcp</a>);</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#ac75ef5b52a26ff6a3fe22047ba16add5">ssrc</a> = ssrc;</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#aaad28f32901e3c4c778e87ce5e6de753">key</a>  = key;</div>
<div class="line">policy.<a class="code" href="structsrtp__policy__t.html#a6e0d2dbb6d41eedb0eb6597f9b7073a8">next</a> = NULL;</div>
<div class="line"></div>
<div class="line"><span class="comment">// allocate and initialize the SRTP session</span></div>
<div class="line"><a class="code" href="group__SRTP.html#gac7874ac09c2a1abf0d893566f933f477">srtp_create</a>(&amp;session, &amp;policy);</div>
<div class="line"></div>
<div class="line"><span class="comment">// main loop: get rtp packets, send srtp packets</span></div>
<div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">  <span class="keywordtype">char</span> rtp_buffer[2048];</div>
<div class="line">  <span class="keywordtype">unsigned</span> len;</div>
<div class="line"></div>
<div class="line">  len = get_rtp_packet(rtp_buffer);</div>
<div class="line">  <a class="code" href="group__SRTP.html#gaed717c57385c7bf1f4369c27ac2742d2">srtp_protect</a>(session, rtp_buffer, &amp;len);</div>
<div class="line">  send_srtp_packet(rtp_buffer, len);</div>
<div class="line">}</div>
</div><!-- fragment --> <hr/>
<p><a class="anchor" id="credits"></a> </p>
<h1>Credits</h1>
<p>The original implementation and documentation of libSRTP was written by David McGrew of Cisco Systems, Inc. in order to promote the use, understanding, and interoperability of Secure RTP. Michael Jerris contributed support for building under MSVC. Andris Pavenis contributed many important fixes. Brian West contributed changes to enable dynamic linking. Yves Shumann reported documentation bugs. Randell Jesup contributed a working SRTCP implementation and other fixes. Steve Underwood contributed x86_64 portability changes. We also give thanks to Fredrik Thulin, Brian Weis, Mark Baugher, Jeff Chan, Bill Simon, Douglas Smith, Bill May, Richard Preistley, Joe Tardo and others for contributions, comments, and corrections.</p>
<p>This reference material, when applicable, in this documenation was generated using the doxygen utility for automatic documentation of source code.</p>
<p>Copyright 2001-2005 by David A. McGrew, Cisco Systems, Inc. </p>
<hr/>
<p><a class="anchor" id="references"></a> </p>
<h1>References</h1>
<p>SRTP and ICM References September, 2005</p>
<p>Secure RTP is defined in <a href="https://www.ietf.org/rfc/rfc3711.txt">RFC 3711</a>. The counter mode definition is in Section 4.1.1.</p>
<p>SHA-1 is defined in FIPS-180-1, available online at the NIST website.</p>
<p>HMAC is defined in <a href="https://www.ietf.org/rfc/rfc2104.txt">RFC2104</a> and HMAC-SHA1 test vectors are available in <a href="https://www.ietf.org/rfc/rfc2202.txt">RFC2202</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
